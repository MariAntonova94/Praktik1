Конечно, давайте разберем весь код построчно и добавим подробные комментарии для новичков.

c
Копировать код
#include <stdio.h>       // Включение стандартной библиотеки ввода-вывода для работы с функциями ввода/вывода
#include <stdlib.h>      // Включение стандартной библиотеки для работы с функциями памяти, процессов и т.д.
#include <unistd.h>      // Включение стандартной библиотеки для работы с POSIX API (ввод/вывод и др.)
#include <termios.h>     // Включение библиотеки для управления режимами терминала
#include <sys/select.h>  // Включение библиотеки для функций мультиплексирования ввода-вывода

// Определение размеров игрового поля и ракеток
#define FIELD_WIDTH 80
#define FIELD_HEIGHT 25
#define ROCKET_HEIGHT 3
#define WINSCORE 21
#define ROCKET1_X 2                // Позиция первой ракетки по X (левая сторона)
#define ROCKET2_X (FIELD_WIDTH - 3) // Позиция второй ракетки по X (правая сторона)
#define BALL_START_X (FIELD_WIDTH / 2) // Начальная позиция мяча по X
#define BALL_START_Y (FIELD_HEIGHT / 2) // Начальная позиция мяча по Y

// Объявление глобальных переменных
char move;              // Переменная для хранения последнего нажатого символа
int sc, ball_coord_x, ball_coord_y, rocket_coord1, rocket_coord2, vector_x, vector_y; // Координаты и векторы движения мяча и ракеток
int score_player1 = 0;  // Счет игрока 1
int score_player2 = 0;  // Счет игрока 2

struct termios orig_termios; // Структура для хранения исходных настроек терминала

// Прототипы функций
void first_player_move();     // Функция для обработки хода первого игрока
void second_player_move();    // Функция для обработки хода второго игрока
void ball_position();         // Функция для обработки движения мяча
void draw_field();            // Функция для отрисовки игрового поля
void reset_terminal_mode();   // Функция для восстановления исходных настроек терминала
void set_conio_terminal_mode(); // Функция для установки неканонического режима терминала
int kbhit();                  // Функция для проверки нажатия клавиши
char getch();                 // Функция для чтения символа с клавиатуры

// Основная функция
int main(void) {
    // Начальные позиции ракеток и мяча
    rocket_coord1 = FIELD_HEIGHT / 2 - ROCKET_HEIGHT / 2; // Центрирование первой ракетки
    rocket_coord2 = FIELD_HEIGHT / 2 - ROCKET_HEIGHT / 2; // Центрирование второй ракетки
    ball_coord_x = BALL_START_X; // Центрирование мяча по X
    ball_coord_y = BALL_START_Y; // Центрирование мяча по Y
    vector_x = 1; // Начальное направление мяча по горизонтали (вправо)
    vector_y = 1; // Начальное направление мяча по вертикали (вниз)

    set_conio_terminal_mode(); // Установка неканонического режима терминала для ввода с клавиатуры

    // Главный игровой цикл
    while (score_player1 < WINSCORE && score_player2 < WINSCORE) {
        draw_field(); // Отрисовка игрового поля
        if (kbhit()) { // Проверка, была ли нажата клавиша
            move = getch(); // Чтение нажатой клавиши
            first_player_move(); // Обработка хода первого игрока
            second_player_move(); // Обработка хода второго игрока
        }
        ball_position(); // Обработка движения мяча
        usleep(100000); // Задержка для замедления игры (0.1 секунды)
    }

    printf("\033[2J\033[H"); // Очистка экрана
    if (score_player1 == WINSCORE) { // Проверка, выиграл ли первый игрок
        printf("Player 1 wins!\n");
    } else { // Иначе выиграл второй игрок
        printf("Player 2 wins!\n");
    }

    reset_terminal_mode(); // Восстановление исходных настроек терминала
    return 0;
}

// Функция для обработки хода первого игрока
void first_player_move() {
    // Перемещение первой ракетки вверх
    if (move == 'a' && rocket_coord1 > 0) {
        rocket_coord1--;
    // Перемещение первой ракетки вниз
    } else if (move == 'z' && rocket_coord1 < FIELD_HEIGHT - ROCKET_HEIGHT) {
        rocket_coord1++;
    }
}

// Функция для обработки хода второго игрока
void second_player_move() {
    // Перемещение второй ракетки вверх
    if (move == 'k' && rocket_coord2 > 0) {
        rocket_coord2--;
    // Перемещение второй ракетки вниз
    } else if (move == 'm' && rocket_coord2 < FIELD_HEIGHT - ROCKET_HEIGHT) {
        rocket_coord2++;
    }
}

// Функция для обработки движения мяча
void ball_position() {
    // Проверка на попадание в верхнюю или нижнюю границу поля
    if (ball_coord_y <= 0 || ball_coord_y >= FIELD_HEIGHT - 1) {
        vector_y = -vector_y; // Изменение направления по вертикали
    }
    
    // Проверка на попадание в ракетку первого игрока
    if (ball_coord_x == ROCKET1_X + 1 && ball_coord_y >= rocket_coord1 && ball_coord_y < rocket_coord1 + ROCKET_HEIGHT) {
        vector_x = -vector_x; // Изменение направления по горизонтали
    }
    
    // Проверка на попадание в ракетку второго игрока
    if (ball_coord_x == ROCKET2_X - 1 && ball_coord_y >= rocket_coord2 && ball_coord_y < rocket_coord2 + ROCKET_HEIGHT) {
        vector_x = -vector_x; // Изменение направления по горизонтали
    }
    
    // Проверка на пропуск ракетки и увеличение счета
    if (ball_coord_x <= 0) {
        score_player2++; // Увеличение счета второго игрока
        ball_coord_x = BALL_START_X; // Возврат мяча в центр
        ball_coord_y = BALL_START_Y;
        vector_x = 1; // Смена направления
        vector_y = 1;
    } else if (ball_coord_x >= FIELD_WIDTH - 1) {
        score_player1++; // Увеличение счета первого игрока
        ball_coord_x = BALL_START_X; // Возврат мяча в центр
        ball_coord_y = BALL_START_Y;
        vector_x = -1; // Смена направления
        vector_y = 1;
    } else {
        ball_coord_x += vector_x; // Перемещение мяча по X
        ball_coord_y += vector_y; // Перемещение мяча по Y
    }
}

// Функция для отрисовки игрового поля
void draw_field() {
    printf("\033[2J\033[H"); // Очистка экрана

    // Проход по всем координатам поля
    for (int y = 0; y < FIELD_HEIGHT; y++) {
        for (int x = 0; x < FIELD_WIDTH; x++) {
            // Рисование верхней и нижней границы
            if (y == 0 || y == FIELD_HEIGHT - 1) {
                putchar('-'); // Верхняя и нижняя границы
            } else if (x == 0 || x == FIELD_WIDTH - 1) {
                putchar('|'); // Левая и правая границы
            } 
            // Рисование ракеток
            else if ((x == ROCKET1_X && y >= rocket_coord1 && y < rocket_coord1 + ROCKET_HEIGHT) ||
                (x == ROCKET2_X && y >= rocket_coord2 && y < rocket_coord2 + ROCKET_HEIGHT)) {
                putchar('|');
            } 
            // Рисование мяча
            else if (x == ball_coord_x && y == ball_coord_y) {
                putchar('O');
            } 
            // Рисование центральной линии
            else if (x == FIELD_WIDTH / 2) {
                putchar('|');
            } else {
                putchar(' ');
            }
        }
        putchar('\n'); // Перевод строки после каждого ряда
    }
    // Вывод счета игроков
    printf("Score: Player 1 - %d | Player 2 - %d\n", score_player1, score_player2);
}

// Настройки терминала для неканонического режима
void reset_terminal_mode() {
    tcsetattr(0, TCSANOW, &orig_termios); // Восстановление исходных настроек терминала
}

void set_conio_terminal_mode() {
    struct termios new_termios;

    // Копирование текущих настроек терминала для изменения и последующего восстановления
    tcgetattr(0, &orig_termios);
    new_termios = orig_termios;

    // Регистрация функции для восстановления настроек терминала при выходе
    atexit(reset_terminal_mode);
    cfmakeraw(&new_termios); // Установка терминала в неканонический режим
    tcsetattr(0, TCSANOW, &new_termios); // Применение новых настроек терминала
}

// Проверка наличия нажатия клавиши
int kbhit() {
    struct timeval tv = { 0L, 0L };
    fd_set fds;
    FD_ZERO(&fds); // Очистка набора дескрипторов
    FD_SET(0, &fds); // Добавление стандартного ввода в набор дескрипторов
    return select(1, &fds, NULL, NULL, &tv); // Проверка состояния дескрипторов
}

// Чтение символа с клавиатуры
char getch() {
    char buf = 0;
    if (read(0, &buf, 1) < 0) { // Чтение одного символа из стандартного ввода
        perror("read()"); // Вывод ошибки при неудачном чтении
        exit(EXIT_FAILURE); // Завершение программы с ошибкой
    }
    return buf; // Возврат прочитанного символа
}
Подробное объяснение кода
Подключение библиотек
c
Копировать код
#include <stdio.h>       // Включение стандартной библиотеки ввода-вывода для работы с функциями ввода/вывода
#include <stdlib.h>      // Включение стандартной библиотеки для работы с функциями памяти, процессов и т.д.
#include <unistd.h>      // Включение стандартной библиотеки для работы с POSIX API (ввод/вывод и др.)
#include <termios.h>     // Включение библиотеки для управления режимами терминала
#include <sys/select.h>  // Включение библиотеки для функций мультиплексирования ввода-вывода
Эти библиотеки необходимы для работы с вводом/выводом, управлением терминалом и другими системными функциями.

Определение констант
c
Копировать код
#define FIELD_WIDTH 80
#define FIELD_HEIGHT 25
#define ROCKET_HEIGHT 3
#define WINSCORE 21
#define ROCKET1_X 2                // Позиция первой ракетки по X (левая сторона)
#define ROCKET2_X (FIELD_WIDTH - 3) // Позиция второй ракетки по X (правая сторона)
#define BALL_START_X (FIELD_WIDTH / 2) // Начальная позиция мяча по X
#define BALL_START_Y (FIELD_HEIGHT / 2) // Начальная позиция мяча по Y
Здесь мы задаем размеры игрового поля, ракеток, количество очков для победы, и начальные координаты ракеток и мяча.

Объявление глобальных переменных
c
Копировать код
char move;              // Переменная для хранения последнего нажатого символа
int sc, ball_coord_x, ball_coord_y, rocket_coord1, rocket_coord2, vector_x, vector_y; // Координаты и векторы движения мяча и ракеток
int score_player1 = 0;  // Счет игрока 1
int score_player2 = 0;  // Счет игрока 2

struct termios orig_termios; // Структура для хранения исходных настроек терминала
Здесь объявляются глобальные переменные для хранения состояния игры: положение мяча и ракеток, направления движения, счет игроков и настройки терминала.

Прототипы функций
c
Копировать код
void first_player_move();     // Функция для обработки хода первого игрока
void second_player_move();    // Функция для обработки хода второго игрока
void ball_position();         // Функция для обработки движения мяча
void draw_field();            // Функция для отрисовки игрового поля
void reset_terminal_mode();   // Функция для восстановления исходных настроек терминала
void set_conio_terminal_mode(); // Функция для установки неканонического режима терминала
int kbhit();                  // Функция для проверки нажатия клавиши
char getch();                 // Функция для чтения символа с клавиатуры
Эти функции будут использоваться для управления игрой и взаимодействия с пользователем.

Основная функция
c
Копировать код
int main(void) {
    // Начальные позиции ракеток и мяча
    rocket_coord1 = FIELD_HEIGHT / 2 - ROCKET_HEIGHT / 2; // Центрирование первой ракетки
    rocket_coord2 = FIELD_HEIGHT / 2 - ROCKET_HEIGHT / 2; // Центрирование второй ракетки
    ball_coord_x = BALL_START_X; // Центрирование мяча по X
    ball_coord_y = BALL_START_Y; // Центрирование мяча по Y
    vector_x = 1; // Начальное направление мяча по горизонтали (вправо)
    vector_y = 1; // Начальное направление мяча по вертикали (вниз)

    set_conio_terminal_mode(); // Установка неканонического режима терминала для ввода с клавиатуры

    // Главный игровой цикл
    while (score_player1 < WINSCORE && score_player2 < WINSCORE) {
        draw_field(); // Отрисовка игрового поля
        if (kbhit()) { // Проверка, была ли нажата клавиша
            move = getch(); // Чтение нажатой клавиши
            first_player_move(); // Обработка хода первого игрока
            second_player_move(); // Обработка хода второго игрока
        }
        ball_position(); // Обработка движения мяча
        usleep(100000); // Задержка для замедления игры (0.1 секунды)
    }

    printf("\033[2J\033[H"); // Очистка экрана
    if (score_player1 == WINSCORE) { // Проверка, выиграл ли первый игрок
        printf("Player 1 wins!\n");
    } else { // Иначе выиграл второй игрок
        printf("Player 2 wins!\n");
    }

    reset_terminal_mode(); // Восстановление исходных настроек терминала
    return 0;
}
Главная функция инициализирует начальные позиции мяча и ракеток, устанавливает терминал в неканонический режим и запускает главный игровой цикл, который продолжается до достижения одним из игроков 21 очка. В цикле происходит отрисовка игрового поля, обработка ввода с клавиатуры и движение мяча.

Функция обработки хода первого игрока
c
Копировать код
void first_player_move() {
    // Перемещение первой ракетки вверх
    if (move == 'a' && rocket_coord1 > 0) {
        rocket_coord1--;
    // Перемещение первой ракетки вниз
    } else if (move == 'z' && rocket_coord1 < FIELD_HEIGHT - ROCKET_HEIGHT) {
        rocket_coord1++;
    }
}
Эта функция обрабатывает перемещение первой ракетки (игрок 1). Если нажата клавиша 'a', ракетка движется вверх, если 'z' — вниз. Проверяется, чтобы ракетка не выходила за границы поля.

Функция обработки хода второго игрока
c
Копировать код
void second_player_move() {
    // Перемещение второй ракетки вверх
    if (move == 'k' && rocket_coord2 > 0) {
        rocket_coord2--;
    // Перемещение второй ракетки вниз
    } else if (move == 'm' && rocket_coord2 < FIELD_HEIGHT - ROCKET_HEIGHT) {
        rocket_coord2++;
    }
}
Аналогично первой функции, но для второго игрока. Если нажата клавиша 'k', ракетка движется вверх, если 'm' — вниз.

Функция обработки движения мяча
c
Копировать код
void ball_position() {
    // Проверка на попадание в верхнюю или нижнюю границу поля
    if (ball_coord_y <= 0 || ball_coord_y >= FIELD_HEIGHT - 1) {
        vector_y = -vector_y; // Изменение направления по вертикали
    }
    
    // Проверка на попадание в ракетку первого игрока
    if (ball_coord_x == ROCKET1_X + 1 && ball_coord_y >= rocket_coord1 && ball_coord_y < rocket_coord1 + ROCKET_HEIGHT) {
        vector_x = -vector_x; // Изменение направления по горизонтали
    }
    
    // Проверка на попадание в ракетку второго игрока
    if (ball_coord_x == ROCKET2_X - 1 && ball_coord_y >= rocket_coord2 && ball_coord_y < rocket_coord2 + ROCKET_HEIGHT) {
        vector_x = -vector_x; // Изменение направления по горизонтали
    }
    
    // Проверка на пропуск ракетки и увеличение счета
    if (ball_coord_x <= 0) {
        score_player2++; // Увеличение счета второго игрока
        ball_coord_x = BALL_START_X; // Возврат мяча в центр
        ball_coord_y = BALL_START_Y;
        vector_x = 1; // Смена направления
        vector_y = 1;
    } else if (ball_coord_x >= FIELD_WIDTH - 1) {
        score_player1++; // Увеличение счета первого игрока
        ball_coord_x = BALL_START_X; // Возврат мяча в центр
        ball_coord_y = BALL_START_Y;
        vector_x = -1; // Смена направления
        vector_y = 1;
    } else {
        ball_coord_x += vector_x; // Перемещение мяча по X
        ball_coord_y += vector_y; // Перемещение мяча по Y
    }
}
Эта функция обрабатывает движение мяча. Мяч отскакивает от верхней и нижней границ поля, а также от ракеток игроков. Если мяч выходит за левую или правую границу поля, увеличивается счет соответствующего игрока, и мяч возвращается в центр поля.

Функция отрисовки игрового поля
c
Копировать код
void draw_field() {
    printf("\033[2J\033[H"); // Очистка экрана

    // Проход по всем координатам поля
    for (int y = 0; y < FIELD_HEIGHT; y++) {
        for (int x = 0; x < FIELD_WIDTH; x++) {
            // Рисование верхней и нижней границы
            if (y == 0 || y == FIELD_HEIGHT - 1) {
                putchar('-'); // Верхняя и нижняя границы
            } else if (x == 0 || x == FIELD_WIDTH - 1) {
                putchar('|'); // Левая и правая границы
            } 
            // Рисование ракеток
            else if ((x == ROCKET1_X && y >= rocket_coord1 && y < rocket_coord1 + ROCKET_HEIGHT) ||
                (x == ROCKET2_X && y >= rocket_coord2 && y < rocket_coord2 + ROCKET_HEIGHT)) {
                putchar('|');
            } 
            // Рисование мяча
            else if (x == ball_coord_x && y == ball_coord_y) {
                putchar('O');
            } 
            // Рисование центральной линии
            else if (x == FIELD_WIDTH / 2) {
                putchar('|');
            } else {
                putchar(' ');
            }
        }
        putchar('\n'); // Перевод строки после каждого ряда
    }
    // Вывод счета игроков
    printf("Score: Player 1 - %d | Player 2 - %d\n", score_player1, score_player2);
}
Функция рисует игровое поле, включая границы, ракетки, мяч и центральную линию. Также отображается текущий счет игры.

Функции для работы с терминалом
c
Копировать код
void reset_terminal_mode() {
    tcsetattr(0, TCSANOW, &orig_termios); // Восстановление исходных настроек терминала
}

void set_conio_terminal_mode() {
    struct termios new_termios;

    // Копирование текущих настроек терминала для изменения и последующего восстановления
    tcgetattr(0, &orig_termios);
    new_termios = orig_termios;

    // Регистрация функции для восстановления настроек терминала при выходе
    atexit(reset_terminal_mode);
    cfmakeraw(&new_termios); // Установка терминала в неканонический режим
    tcsetattr(0, TCSANOW, &new_termios); // Применение новых настроек терминала
}
Эти функции управляют режимом работы терминала. set_conio_terminal_mode переводит терминал в неканонический режим, в котором ввод с клавиатуры обрабатывается немедленно, без ожидания нажатия клавиши Enter. reset_terminal_mode восстанавливает исходные настройки терминала при завершении программы.

Проверка нажатия клавиши и чтение символа
c
Копировать код
int kbhit() {
    struct timeval tv = { 0L, 0L };
    fd_set fds;
    FD_ZERO(&fds); // Очистка набора дескрипторов
    FD_SET(0, &fds); // Добавление стандартного ввода в набор дескрипторов
    return select(1, &fds, NULL, NULL, &tv); // Проверка состояния дескрипторов
}

char getch() {
    char buf = 0;
    if (read(0, &buf, 1) < 0) { // Чтение одного символа из стандартного ввода
        perror("read()"); // Вывод ошибки при неудачном чтении
        exit(EXIT_FAILURE); // Завершение программы с ошибкой
    }
    return buf; // Возврат прочитанного символа
}
Функция kbhit проверяет, была ли нажата клавиша, используя функцию select. Если клавиша нажата, функция getch читает и возвращает этот символ.

Заключение
Этот код представляет собой простую текстовую игру Pong для терминала, написанную на языке C. Мы рассмотрели основные компоненты программы, такие как инициализация игры, обработка ввода с клавиатуры, движение мяча и ракеток, отрисовка игрового поля и управление режимом работы терминала.






















План лекции:
Введение

Приветствие
Цель лекции: Показать, как реализовать простую текстовую игру Pong на языке C
Краткий обзор того, что будет рассмотрено: подключение библиотек, определение констант, объявление глобальных переменных, основные функции, обработка ввода с клавиатуры, отрисовка игрового поля.
Подключение библиотек

Объяснение, зачем нужны стандартные библиотеки
Что включают библиотеки stdio.h, stdlib.h, unistd.h, termios.h, sys/select.h
Определение констант

Почему мы используем константы
Пояснение каждой константы: размеры игрового поля, ракеток, начальные позиции, счет
Объявление глобальных переменных

Что такое глобальные переменные и почему они используются
Пояснение каждой переменной
Прототипы функций

Почему важно объявлять прототипы функций
Пояснение назначения каждой функции
Основная функция main

Пошаговое объяснение функции main: инициализация игры, главный игровой цикл, завершение игры
Важность установки неканонического режима терминала
Функции обработки хода игроков

Объяснение функций first_player_move и second_player_move
Демонстрация обработки нажатий клавиш для управления ракетками
Функция обработки движения мяча

Пояснение логики движения мяча и взаимодействия с границами и ракетками
Демонстрация кода на примере
Функция отрисовки игрового поля

Объяснение, как рисуется игровое поле, ракетки и мяч
Показ кода и объяснение каждой части
Функции для работы с терминалом

Объяснение важности управления режимом терминала
Пояснение функций reset_terminal_mode и set_conio_terminal_mode
Проверка нажатия клавиши и чтение символа

Объяснение, как проверяется наличие нажатия клавиши
Пояснение функций kbhit и getch
Заключение

Обобщение изученного материала
Ответы на вопросы
Рекомендации для самостоятельной практики
Детализированный текст лекции:
Введение
Приветствие:
"Добрый день, коллеги! Сегодня мы с вами рассмотрим, как можно реализовать простую текстовую игру Pong на языке C. Мы разберем основные этапы написания программы: подключение библиотек, определение констант, объявление глобальных переменных, реализация основных функций и обработка ввода с клавиатуры."

Цель лекции:
"Цель нашей лекции - научиться использовать язык C для создания интерактивных приложений, в частности, текстовых игр. Мы разберем каждый шаг программы, чтобы у вас было четкое понимание того, как работает код."

Подключение библиотек
"Для начала, давайте посмотрим на подключение библиотек. В верхней части нашего кода мы видим несколько строк, начинающихся с #include. Эти строки указывают компилятору на использование внешних библиотек."

c
Копировать код
#include <stdio.h>       // Включение стандартной библиотеки ввода-вывода для работы с функциями ввода/вывода
#include <stdlib.h>      // Включение стандартной библиотеки для работы с функциями памяти, процессов и т.д.
#include <unistd.h>      // Включение стандартной библиотеки для работы с POSIX API (ввод/вывод и др.)
#include <termios.h>     // Включение библиотеки для управления режимами терминала
#include <sys/select.h>  // Включение библиотеки для функций мультиплексирования ввода-вывода
"Библиотека stdio.h позволяет нам использовать функции ввода-вывода, такие как printf и scanf. Библиотека stdlib.h предоставляет функции для работы с памятью и процессами, такие как malloc и exit. Библиотека unistd.h необходима для работы с POSIX API, включая функции управления файлами и процессами. Библиотека termios.h позволяет управлять режимами терминала, а sys/select.h используется для мультиплексирования ввода-вывода."

Определение констант
"Теперь перейдем к определению констант. Константы используются для задания фиксированных значений, которые не изменяются в ходе выполнения программы."

c
Копировать код
#define FIELD_WIDTH 80
#define FIELD_HEIGHT 25
#define ROCKET_HEIGHT 3
#define WINSCORE 21
#define ROCKET1_X 2                // Позиция первой ракетки по X (левая сторона)
#define ROCKET2_X (FIELD_WIDTH - 3) // Позиция второй ракетки по X (правая сторона)
#define BALL_START_X (FIELD_WIDTH / 2) // Начальная позиция мяча по X
#define BALL_START_Y (FIELD_HEIGHT / 2) // Начальная позиция мяча по Y
"Эти константы задают размеры игрового поля и ракеток, количество очков для победы, а также начальные позиции ракеток и мяча. Например, FIELD_WIDTH определяет ширину поля, FIELD_HEIGHT - высоту, ROCKET_HEIGHT - высоту ракетки, а WINSCORE - количество очков, необходимых для победы."

Объявление глобальных переменных
"Далее у нас идут глобальные переменные. Глобальные переменные объявляются вне всех функций и доступны во всей программе."

c
Копировать код
char move;              // Переменная для хранения последнего нажатого символа
int sc, ball_coord_x, ball_coord_y, rocket_coord1, rocket_coord2, vector_x, vector_y; // Координаты и векторы движения мяча и ракеток
int score_player1 = 0;  // Счет игрока 1
int score_player2 = 0;  // Счет игрока 2

struct termios orig_termios; // Структура для хранения исходных настроек терминала
"Переменная move используется для хранения последнего нажатого символа. Переменные ball_coord_x, ball_coord_y, rocket_coord1, rocket_coord2, vector_x и vector_y хранят координаты и направления движения мяча и ракеток. score_player1 и score_player2 хранят счет игроков. Структура orig_termios используется для хранения исходных настроек терминала."

Прототипы функций
"Прототипы функций объявляются до основной функции main и позволяют нам использовать функции до их определения."

c
Копировать код
void first_player_move();     // Функция для обработки хода первого игрока
void second_player_move();    // Функция для обработки хода второго игрока
void ball_position();         // Функция для обработки движения мяча
void draw_field();            // Функция для отрисовки игрового поля
void reset_terminal_mode();   // Функция для восстановления исходных настроек терминала
void set_conio_terminal_mode(); // Функция для установки неканонического режима терминала
int kbhit();                  // Функция для проверки нажатия клавиши
char getch();                 // Функция для чтения символа с клавиатуры
"Каждая из этих функций имеет свою задачу. Например, first_player_move и second_player_move обрабатывают ходы игроков, ball_position обрабатывает движение мяча, draw_field рисует игровое поле, reset_terminal_mode и set_conio_terminal_mode управляют режимом терминала, а kbhit и getch работают с вводом с клавиатуры."

Основная функция main
"Теперь рассмотрим основную функцию main. Она инициализирует начальные позиции мяча и ракеток, устанавливает терминал в неканонический режим и запускает главный игровой цикл."

c
Копировать код
int main(void) {
    // Начальные позиции ракеток и мяча
    rocket_coord1 = FIELD_HEIGHT / 2 - ROCKET_HEIGHT / 2; // Центрирование первой ракетки
    rocket_coord2 = FIELD_HEIGHT / 2 - ROCKET_HEIGHT / 2; // Центрирование второй ракетки
    ball_coord_x = BALL_START_X; // Центрирование мяча по X
    ball_coord_y = BALL_START_Y; // Центрирование мяча по Y
    vector_x = 1; // Начальное направление мяча по горизонтали (вправо)
    vector_y = 1; // Начальное направление мяча по вертикали (вниз)

    set_conio_terminal_mode(); // Установка неканонического режима терминала для ввода с клавиатуры

    // Главный игровой цикл
    while (score_player1 < WINSCORE && score_player2 < WINSCORE) {
        draw_field(); // Отрисовка игрового поля
        if (kbhit()) { // Проверка, была ли нажата клавиша
            move = getch(); // Чтение нажатой клавиши
            first_player_move(); // Обработка хода первого игрока
            second_player_move(); // Обработка хода второго игрока
        }
        ball_position(); // Обработка движения мяча
        usleep(100000); // Задержка для замедления игры (0.1 секунды)
    }

    printf("\033[2J\033[H"); // Очистка экрана
    if (score_player1 == WINSCORE) { // Проверка, выиграл ли первый игрок
        printf("Player 1 wins!\n");
    } else { // Иначе выиграл второй игрок
        printf("Player 2 wins!\n");
    }

    reset_terminal_mode(); // Восстановление исходных настроек терминала
    return 0;
}
"Инициализация начальных позиций делает так, чтобы ракетки и мяч были по центру игрового поля. Функция set_conio_terminal_mode переводит терминал в неканонический режим, чтобы мы могли обрабатывать ввод с клавиатуры в реальном времени. Главный игровой цикл продолжается, пока один из игроков не наберет необходимое количество очков. Внутри цикла мы отрисовываем игровое поле, обрабатываем нажатия клавиш и движение мяча. Если игра заканчивается, мы очищаем экран и выводим сообщение о победе."

Функции обработки хода игроков
"Функции first_player_move и second_player_move обрабатывают нажатия клавиш для управления ракетками игроков."

c
Копировать код
void first_player_move() {
    if (move == 'a' && rocket_coord1 > 0) {
        rocket_coord1--; // Перемещение первой ракетки вверх
    } else if (move == 'z' && rocket_coord1 < FIELD_HEIGHT - ROCKET_HEIGHT) {
        rocket_coord1++; // Перемещение первой ракетки вниз
    }
}

void second_player_move() {
    if (move == 'k' && rocket_coord2 > 0) {
        rocket_coord2--; // Перемещение второй ракетки вверх
    } else if (move == 'm' && rocket_coord2 < FIELD_HEIGHT - ROCKET_HEIGHT) {
        rocket_coord2++; // Перемещение второй ракетки вниз
    }
}
"Эти функции проверяют, какая клавиша была нажата (a или z для первого игрока и k или m для второго) и перемещают ракетку вверх или вниз в зависимости от этого. Также они проверяют границы поля, чтобы ракетка не выходила за его пределы."

Функция обработки движения мяча
"Функция ball_position управляет движением мяча и проверяет его столкновения с границами поля и ракетками."

c
Копировать код
void ball_position() {
    if (ball_coord_y <= 0 || ball_coord_y >= FIELD_HEIGHT - 1) {
        vector_y = -vector_y; // Изменение направления по вертикали
    }
    
    if (ball_coord_x == ROCKET1_X + 1 && ball_coord_y >= rocket_coord1 && ball_coord_y < rocket_coord1 + ROCKET_HEIGHT) {
        vector_x = -vector_x; // Изменение направления по горизонтали
    }
    
    if (ball_coord_x == ROCKET2_X - 1 && ball_coord_y >= rocket_coord2 && ball_coord_y < rocket_coord2 + ROCKET_HEIGHT) {
        vector_x = -vector_x; // Изменение направления по горизонтали
    }
    
    if (ball_coord_x <= 0) {
        score_player2++; // Увеличение счета второго игрока
        ball_coord_x = BALL_START_X; // Возврат мяча в центр
        ball_coord_y = BALL_START_Y;
        vector_x = 1; // Смена направления
        vector_y = 1;
    } else if (ball_coord_x >= FIELD_WIDTH - 1) {
        score_player1++; // Увеличение счета первого игрока
        ball_coord_x = BALL_START_X; // Возврат мяча в центр
        ball_coord_y = BALL_START_Y;
        vector_x = -1; // Смена направления
        vector_y = 1;
    } else {
        ball_coord_x += vector_x; // Перемещение мяча по X
        ball_coord_y += vector_y; // Перемещение мяча по Y
    }
}
"Если мяч касается верхней или нижней границы поля, его вертикальное направление меняется на противоположное. Если мяч касается ракетки, его горизонтальное направление также меняется. Если мяч выходит за левую или правую границу поля, счет соответствующего игрока увеличивается, и мяч возвращается в центр поля."

Функция отрисовки игрового поля
"Функция draw_field рисует игровое поле, ракетки, мяч и выводит текущий счет игры."

c
Копировать код
void draw_field() {
    printf("\033[2J\033[H"); // Очистка экрана

    for (int y = 0; y < FIELD_HEIGHT; y++) {
        for (int x = 0; x < FIELD_WIDTH; x++) {
            if (y == 0 || y == FIELD_HEIGHT - 1) {
                putchar('-'); // Верхняя и нижняя границы
            } else if (x == 0 || x == FIELD_WIDTH - 1) {
                putchar('|'); // Левая и правая границы
            } else if ((x == ROCKET1_X && y >= rocket_coord1 && y < rocket_coord1 + ROCKET_HEIGHT) ||
                (x == ROCKET2_X && y >= rocket_coord2 && y < rocket_coord2 + ROCKET_HEIGHT)) {
                putchar('|'); // Ракетки
            } else if (x == ball_coord_x && y == ball_coord_y) {
                putchar('O'); // Мяч
            } else if (x == FIELD_WIDTH / 2) {
                putchar('|'); // Центральная линия
            } else {
                putchar(' ');
            }
        }
        putchar('\n'); // Перевод строки после каждого ряда
    }
    printf("Score: Player 1 - %d | Player 2 - %d\n", score_player1, score_player2);
}
"Сначала функция очищает экран. Затем она проходит по всем координатам поля и рисует соответствующие символы: границы, ракетки, мяч и центральную линию. В конце выводится текущий счет игры."

Функции для работы с терминалом
"Функции reset_terminal_mode и set_conio_terminal_mode управляют режимом работы терминала."

c
Копировать код
void reset_terminal_mode() {
    tcsetattr(0, TCSANOW, &orig_termios); // Восстановление исходных настроек терминала
}

void set_conio_terminal_mode() {
    struct termios new_termios;

    tcgetattr(0, &orig_termios);
    new_termios = orig_termios;

    atexit(reset_terminal_mode);
    cfmakeraw(&new_termios); // Установка терминала в неканонический режим
    tcsetattr(0, TCSANOW, &new_termios); // Применение новых настроек терминала
}
"Функция reset_terminal_mode восстанавливает исходные настройки терминала при завершении программы. Функция set_conio_terminal_mode переводит терминал в неканонический режим, что позволяет нам немедленно обрабатывать ввод с клавиатуры."

Проверка нажатия клавиши и чтение символа
"Функции kbhit и getch проверяют наличие нажатия клавиши и читают символ с клавиатуры."

c
Копировать код
int kbhit() {
    struct timeval tv = { 0L, 0L };
    fd_set fds;
    FD_ZERO(&fds); // Очистка набора дескрипторов
    FD_SET(0, &fds); // Добавление стандартного ввода в набор дескрипторов
    return select(1, &fds, NULL, NULL, &tv); // Проверка состояния дескрипторов
}

char getch() {
    char buf = 0;
    if (read(0, &buf, 1) < 0) { // Чтение одного символа из стандартного ввода
        perror("read()"); // Вывод ошибки при неудачном чтении
        exit(EXIT_FAILURE); // Завершение программы с ошибкой
    }
    return buf; // Возврат прочитанного символа
}
"Функция kbhit использует функцию select для проверки состояния дескрипторов и определяет, была ли нажата клавиша. Функция getch читает один символ из стандартного ввода и возвращает его."

Заключение
"Итак, мы рассмотрели основные компоненты программы для создания текстовой игры Pong на языке C. Мы подключили необходимые библиотеки, определили константы, объявили глобальные переменные, реализовали функции для обработки ходов игроков, движения мяча, отрисовки игрового поля, а также для управления режимом терминала и обработки ввода с клавиатуры. Теперь у вас есть все необходимые знания для создания подобных игр самостоятельно."

"Если у вас есть вопросы, я буду рад ответить. Также рекомендую вам попробовать самостоятельно изменить некоторые параметры игры, чтобы лучше понять, как работает каждая часть кода."

"Спасибо за внимание!"

Этот план и пояснения помогут вам провести лекцию по программированию на языке C, используя пример текстовой игры Pong.
